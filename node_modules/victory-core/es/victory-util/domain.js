import _sortedUniq from "lodash/sortedUniq";
import _isPlainObject from "lodash/isPlainObject";
import _includes from "lodash/includes";
import _flatten from "lodash/flatten";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import Data from "./data";
import Scale from "./scale";
import Helpers from "./helpers";
import Collection from "./collection";

export default {

  /**
   * Returns a domain for a given axis based on props, catefory, or data
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array} the domain for the given axis
   */
  getDomain: function (props, axis) {
    var propsDomain = this.getDomainFromProps(props, axis);
    if (propsDomain) {
      return this.padDomain(propsDomain, props, axis);
    }
    var categoryDomain = this.getDomainFromCategories(props, axis);
    if (categoryDomain) {
      return this.padDomain(categoryDomain, props, axis);
    }
    var dataset = Data.getData(props);
    var domain = this.getDomainFromData(props, axis, dataset);
    return this.cleanDomain(this.padDomain(domain, props, axis), props, axis);
  },


  /**
   * Returns the cleaned domain. Some scale types break when certain data is supplied.
   * This method will replace elements in the domain that break certain scales.
   * So far this method only removes zeroes for log scales
   * @param {Array} domain: the original domain
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array} the cleaned domain
   */
  cleanDomain: function (domain, props, axis) {
    var scaleType = Scale.getScaleType(props, axis);

    if (scaleType !== "log") {
      return domain;
    }

    var rules = function (dom) {
      var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;
      var domainOne = dom[0] === 0 ? almostZero : dom[0];
      var domainTwo = dom[1] === 0 ? almostZero : dom[1];
      return [domainOne, domainTwo];
    };

    return rules(domain);
  },


  /**
   * Returns a domain for a given axis. This method forces the domain to include
   * zero unless the deomain is explicitly specified in props.
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array} the domain for the given axis
   */
  getDomainWithZero: function (props, axis) {
    var propsDomain = this.getDomainFromProps(props, axis);
    if (propsDomain) {
      return this.cleanDomain(this.padDomain(propsDomain, props, axis), props, axis);
    }
    var horizontal = props.horizontal;

    var ensureZero = function (domain, dataset) {
      var currentAxis = Helpers.getCurrentAxis(axis, horizontal);
      if (currentAxis === "x") {
        return domain;
      } else if (!dataset) {
        return [Collection.getMinValue(domain, 0), Collection.getMaxValue(domain, 0)];
      }
      var flatData = _flatten(dataset);
      var minData = flatData.map(function (datum) {
        return datum["_" + currentAxis + "0"] || 0;
      });
      var maxData = flatData.map(function (datum) {
        return datum["_" + currentAxis + "1"] || datum["_" + currentAxis] || 0;
      });
      var min = Collection.getMinValue([].concat(_toConsumableArray(domain), _toConsumableArray(minData), _toConsumableArray(maxData)));
      var max = Collection.getMaxValue([].concat(_toConsumableArray(domain), _toConsumableArray(maxData), _toConsumableArray(minData)));
      return [min, max];
    };
    var categoryDomain = this.getDomainFromCategories(props, axis);
    if (categoryDomain) {
      return this.cleanDomain(this.padDomain(ensureZero(categoryDomain), props, axis), props, axis);
    }
    var dataset = Data.getData(props);
    var domain = ensureZero(this.getDomainFromData(props, axis, dataset), dataset);
    return this.cleanDomain(this.padDomain(domain, props, axis), props, axis);
  },


  /**
   * Returns a the domain for a given axis if domain is given in props
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array|undefined} the domain based on props
   */
  getDomainFromProps: function (props, axis) {
    if (props.domain && props.domain[axis]) {
      return props.domain[axis];
    } else if (props.domain && Array.isArray(props.domain)) {
      return props.domain;
    }
    return undefined;
  },


  /**
   * Returns a domain from a dataset for a given axis
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @param {Array} dataset: an array of data
   * @returns {Array} the domain based on data
   */
  getDomainFromData: function (props, axis, dataset) {
    var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);
    var flatData = _flatten(dataset);
    var allData = flatData.map(function (datum) {
      return typeof datum["_" + currentAxis + "1"] === "undefined" ? datum["_" + currentAxis] : datum["_" + currentAxis + "1"];
    });
    var allMinData = flatData.map(function (datum) {
      return typeof datum["_" + currentAxis + "0"] === "undefined" ? datum["_" + currentAxis] : datum["_" + currentAxis + "0"];
    });
    if (allData.length < 1) {
      return Scale.getBaseScale(props, axis).domain();
    }

    var min = Collection.getMinValue(allMinData);
    var max = Collection.getMaxValue(allData);
    var domain = void 0;
    if (+min === +max) {
      domain = this.getSinglePointDomain(max);
    } else {
      domain = [min, max];
    }
    var angularRange = Math.abs((props.startAngle || 0) - (props.endAngle || 360));
    return props.polar && axis === "x" && angularRange === 360 ? this.getSymmetricDomain(domain, allData) : domain;
  },
  getSinglePointDomain: function (val) {
    // d3-scale does not properly resolve very small differences.
    // eslint-disable-next-line no-magic-numbers
    var verySmallNumber = Math.pow(10, -10);
    var verySmallDate = 1;
    var min = val instanceof Date ? new Date(+val - verySmallDate) : val - verySmallNumber;
    var max = val instanceof Date ? new Date(+val + verySmallDate) : val + verySmallNumber;
    return [min, max];
  },
  getSymmetricDomain: function (domain, data) {
    var processedData = _sortedUniq(data.sort(function (a, b) {
      return a - b;
    }));
    var step = processedData[1] - processedData[0];
    return [domain[0], domain[1] + step];
  },


  /**
   * Returns a domain based tickValues
   * @param {Object} props: the props object
   * @param {String} axis: either x or y
   * @returns {Array} returns a domain from tickValues
   */
  getDomainFromTickValues: function (props, axis) {
    var domain = void 0;
    if (Helpers.stringTicks(props)) {
      domain = [1, props.tickValues.length];
    } else {
      // coerce ticks to numbers
      var ticks = props.tickValues.map(function (value) {
        return +value;
      });
      var initialDomain = [Collection.getMinValue(ticks), Collection.getMaxValue(ticks)];
      domain = props.polar && axis === "x" ? this.getSymmetricDomain(initialDomain, ticks) : initialDomain;
    }
    if (Helpers.isVertical(props)) {
      domain.reverse();
    }
    return domain;
  },


  /**
   * Returns a domain based on categories if they exist
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array|undefined} returns a domain from categories or undefined
   */
  getDomainFromCategories: function (props, axis) {
    var categories = Data.getCategories(props, axis);
    if (!categories) {
      return undefined;
    }
    var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];
    var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {
      memo[string] = index + 1;
      return memo;
    }, {});
    var categoryValues = stringMap ? categories.map(function (value) {
      return stringMap[value];
    }) : categories;
    return [Collection.getMinValue(categoryValues), Collection.getMaxValue(categoryValues)];
  },


  /**
   * Returns a cumulative domain for a set of grouped datasets (i.e. stacked charts)
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @param {Array} datasets: an array of data arrays
   * @returns {Array} the cumulative domain
   */
  getDomainFromGroupedData: function (props, axis, datasets) {
    var horizontal = props.horizontal;

    var dependent = axis === "x" && !horizontal || axis === "y" && horizontal;
    if (dependent && props.categories) {
      return this.getDomainFromCategories(props, axis);
    }
    var globalDomain = this.getDomainFromData(props, axis, datasets);
    // find the cumulative max for stacked chart types
    var cumulativeData = !dependent ? this.getCumulativeData(props, axis, datasets) : [];
    var cumulativeMaxArray = cumulativeData.map(function (dataset) {
      return dataset.reduce(function (memo, val) {
        return val > 0 ? +val + +memo : memo;
      }, 0);
    });
    var cumulativeMinArray = cumulativeData.map(function (dataset) {
      return dataset.reduce(function (memo, val) {
        return val < 0 ? +val + +memo : memo;
      }, 0);
    });

    var cumulativeMin = Math.min.apply(Math, _toConsumableArray(cumulativeMinArray));
    // use greatest min / max
    var domainMin = cumulativeMin < 0 ? cumulativeMin : Collection.getMinValue(globalDomain);
    var domainMax = Collection.getMaxValue.apply(Collection, [globalDomain].concat(_toConsumableArray(cumulativeMaxArray)));
    if (+domainMin === +domainMax) {
      return this.getSinglePointDomain(domainMin);
    }
    return [domainMin, domainMax];
  },


  /**
   * Returns cumulative datasets either by index or category
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @param {Array} datasets: an array of data arrays
   * @returns {Array} an array of data arrays grouped by index or category
   */
  getCumulativeData: function (props, axis, datasets) {
    var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);
    var otherAxis = currentAxis === "x" ? "y" : "x";
    var categories = [];
    var axisValues = [];
    datasets.forEach(function (dataset) {
      dataset.forEach(function (data) {
        if (data.category !== undefined && !_includes(categories, data.category)) {
          categories.push(data.category);
        } else if (!_includes(axisValues, data["_" + otherAxis])) {
          axisValues.push(data["_" + otherAxis]);
        }
      });
    });

    var _dataByCategory = function () {
      return categories.map(function (value) {
        return datasets.reduce(function (prev, data) {
          return data.category === value ? prev.concat(data["_" + axis]) : prev;
        }, []);
      });
    };

    var _dataByIndex = function () {
      return axisValues.map(function (value, index) {
        return datasets.map(function (data) {
          return data[index] && data[index]["_" + currentAxis];
        });
      });
    };
    return categories.length === 0 ? _dataByIndex() : _dataByCategory();
  },


  /**
   * Returns the domain padding appropriate for a given axis
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Object} an object with padding specified for "left" and "right"
   */
  getDomainPadding: function (props, axis) {
    var formatPadding = function (padding) {
      return Array.isArray(padding) ? { left: padding[0], right: padding[1] } : { left: padding, right: padding };
    };

    return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);
  },


  /**
   * Returns the domain with padding from the `domainPadding` prop applied
   * @param {Array} domain: the original domain
   * @param {Object} props: the props object
   * @param {String} axis: the current axis
   * @returns {Array} the domain with padding applied
   */
  padDomain: function (domain, props, axis) {
    if (!props.domainPadding) {
      return domain;
    }

    var padding = this.getDomainPadding(props, axis);
    if (!padding.left && !padding.right) {
      return domain;
    }

    var domainMin = Collection.getMinValue(domain);
    var domainMax = Collection.getMaxValue(domain);
    var range = Helpers.getRange(props, axis);
    var rangeExtent = Math.abs(Math.max.apply(Math, _toConsumableArray(range)) - Math.min.apply(Math, _toConsumableArray(range)));

    // Naive initial padding calculation
    var initialPadding = {
      left: Math.abs(domainMax - domainMin) * padding.left / rangeExtent,
      right: Math.abs(domainMax - domainMin) * padding.right / rangeExtent
    };

    // Adjust the domain by the initial padding
    var adjustedDomain = {
      min: domainMin >= 0 && domainMin - initialPadding.left <= 0 ? 0 : domainMin.valueOf() - initialPadding.left,
      max: domainMax <= 0 && domainMax + initialPadding.right >= 0 ? 0 : domainMax.valueOf() + initialPadding.right
    };

    // re-calculate padding, taking the adjusted domain into account
    var finalPadding = {
      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,
      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent
    };

    // Adjust the domain by the final padding
    var finalDomain = {
      min: domainMin >= 0 && domainMin - finalPadding.left <= 0 ? 0 : domainMin.valueOf() - finalPadding.left,
      max: domainMax >= 0 && domainMax + finalPadding.right <= 0 ? 0 : domainMax.valueOf() + finalPadding.right
    };

    return domainMin instanceof Date || domainMax instanceof Date ? [new Date(finalDomain.min), new Date(finalDomain.max)] : [finalDomain.min, finalDomain.max];
  }
};