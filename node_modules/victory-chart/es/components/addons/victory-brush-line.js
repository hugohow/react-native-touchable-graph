import _pick from "lodash/pick";
import _isFunction from "lodash/isFunction";
import _defaults from "lodash/defaults";
import _assign from "lodash/assign";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import React from "react";
import PropTypes from "prop-types";
import { Selection, Helpers, Collection, Axis, Scale, Domain, Box } from "victory-core";

import isEqual from "react-fast-compare";

var getScale = function (props) {
  var _props$scale = props.scale,
      scale = _props$scale === undefined ? {} : _props$scale,
      _props$dimension = props.dimension,
      dimension = _props$dimension === undefined ? "x" : _props$dimension;

  if (scale[dimension]) {
    return scale[dimension];
  }
  var fallbackScale = Scale.getBaseScale(props, dimension);
  var range = Helpers.getRange(props, dimension);
  var domain = Domain.getDomainFromProps(props, dimension) || [0, 1];
  fallbackScale.range(range).domain(domain);
  return fallbackScale;
};

var toRange = function (props, domain) {
  var scale = getScale(props);
  return [scale(Math.min.apply(Math, _toConsumableArray(domain))), scale(Math.max.apply(Math, _toConsumableArray(domain)))];
};

var toDomain = function (props, range) {
  var scale = getScale(props);
  return [scale.invert(Math.min.apply(Math, _toConsumableArray(range))), scale.invert(Math.max.apply(Math, _toConsumableArray(range)))];
};

var getFullRange = function (props) {
  var scale = getScale(props);
  return scale.range();
};

var getFullDomain = function (props) {
  var scale = getScale(props);
  return scale.domain();
};

var withinBound = function (value, bound) {
  return value >= Math.min.apply(Math, _toConsumableArray(bound)) && value <= Math.max.apply(Math, _toConsumableArray(bound));
};

var getActiveHandle = function (props, position, range) {
  var width = props.handleWidth / 2;
  var dimension = props.dimension;

  var getHandle = function (type) {
    var base = {
      min: dimension === "x" ? Math.min.apply(Math, _toConsumableArray(range)) : Math.max.apply(Math, _toConsumableArray(range)),
      max: dimension === "x" ? Math.max.apply(Math, _toConsumableArray(range)) : Math.min.apply(Math, _toConsumableArray(range))
    };
    return [base[type] - width, base[type] + width];
  };
  var active = ["min", "max"].reduce(function (memo, type) {
    memo[type] = withinBound(position, getHandle(type)) ? type : undefined;
    return memo;
  }, {});
  return active.min && active.max ? "both" : active.min || active.max;
};

var getMinimumDomain = function () {
  return [0, 1 / Number.MAX_SAFE_INTEGER];
};

var panBox = function (props, position) {
  var brushDomain = props.brushDomain,
      startPosition = props.startPosition;

  var range = toRange(props, brushDomain);
  var fullRange = getFullRange(props);
  var size = Math.abs(range[1] - range[0]);
  var globalMin = Math.min.apply(Math, _toConsumableArray(fullRange));
  var globalMax = Math.max.apply(Math, _toConsumableArray(fullRange));
  var delta = startPosition ? startPosition - position : 0;
  var min = Math.min.apply(Math, _toConsumableArray(range)) - delta;
  var max = Math.max.apply(Math, _toConsumableArray(range)) - delta;
  var constrainedMin = min > globalMax - size ? globalMax - size : Math.max(min, globalMin);
  var constrainedMax = max < globalMin + size ? globalMin + size : Math.min(max, globalMax);
  return [constrainedMin, constrainedMax];
};

var fallbackProps = {
  brushAreaStyle: {
    stroke: "none",
    fill: "black",
    opacity: function (d, a) {
      return a ? 0.2 : 0.1;
    } // eslint-disable-line no-magic-numbers
  },
  brushStyle: {
    pointerEvents: "none",
    stroke: "none",
    fill: "black",
    opacity: function (d, a) {
      return a ? 0.4 : 0.3;
    } // eslint-disable-line no-magic-numbers
  }, handleStyle: {
    pointerEvents: "none",
    stroke: "none",
    fill: "none"
  }
};

var VictoryBrushLine = function (_React$Component) {
  _inherits(VictoryBrushLine, _React$Component);

  function VictoryBrushLine() {
    _classCallCheck(this, VictoryBrushLine);

    return _possibleConstructorReturn(this, (VictoryBrushLine.__proto__ || Object.getPrototypeOf(VictoryBrushLine)).apply(this, arguments));
  }

  _createClass(VictoryBrushLine, [{
    key: "getRectDimensions",
    value: function getRectDimensions(props, brushWidth, domain) {
      var dimension = props.dimension,
          brushDomain = props.brushDomain;

      domain = domain || brushDomain || getFullDomain(props);
      var range = toRange(props, domain);
      var coordinates = dimension === "x" ? { y1: props.y1, y2: props.y2, x1: Math.min.apply(Math, _toConsumableArray(range)), x2: Math.max.apply(Math, _toConsumableArray(range)) } : { x1: props.x1, x2: props.x2, y1: Math.min.apply(Math, _toConsumableArray(range)), y2: Math.max.apply(Math, _toConsumableArray(range)) };
      var x1 = coordinates.x1,
          x2 = coordinates.x2,
          y1 = coordinates.y1,
          y2 = coordinates.y2;

      var offset = {
        x: dimension === "x" ? 0 : brushWidth / 2,
        y: dimension === "y" ? 0 : brushWidth / 2
      };

      var x = Math.min(x1, x2) - offset.x;
      var y = Math.min(y1, y2) - offset.y;
      var width = Math.max(x1, x2) + offset.x - x;
      var height = Math.max(y1, y2) + offset.y - y;
      return { x: x, y: y, width: width, height: height };
    }
  }, {
    key: "getHandleDimensions",
    value: function getHandleDimensions(props) {
      var dimension = props.dimension,
          handleWidth = props.handleWidth,
          x1 = props.x1,
          x2 = props.x2,
          y1 = props.y1,
          y2 = props.y2,
          brushDomain = props.brushDomain;

      var brushWidth = props.brushWidth || props.width;
      var domain = brushDomain || getFullDomain(props);
      var range = toRange(props, domain);
      var defaultX = Math.min(x1, x2) - brushWidth / 2;
      var defaultY = Math.min(y1, y2) - brushWidth / 2;
      var x = {
        min: dimension === "x" ? Math.min.apply(Math, _toConsumableArray(range)) - handleWidth / 2 : defaultX,
        max: dimension === "x" ? Math.max.apply(Math, _toConsumableArray(range)) - handleWidth / 2 : defaultX
      };
      var y = {
        min: dimension === "y" ? Math.max.apply(Math, _toConsumableArray(range)) - handleWidth / 2 : defaultY,
        max: dimension === "y" ? Math.min.apply(Math, _toConsumableArray(range)) - handleWidth / 2 : defaultY
      };
      var width = dimension === "x" ? handleWidth : brushWidth;
      var height = dimension === "x" ? brushWidth : handleWidth;

      return {
        min: { x: x.min, y: y.min, width: width, height: height },
        max: { x: x.max, y: y.max, width: width, height: height }
      };
    }
  }, {
    key: "getCursor",
    value: function getCursor(props) {
      var dimension = props.dimension,
          _props$activeBrushes = props.activeBrushes,
          activeBrushes = _props$activeBrushes === undefined ? {} : _props$activeBrushes;

      if (activeBrushes.minHandle || activeBrushes.maxHandle) {
        return dimension === "x" ? "ew-resize" : "ns-resize";
      } else if (activeBrushes.brush) {
        return "move";
      }
      return "crosshair";
    }
  }, {
    key: "renderHandles",
    value: function renderHandles(props) {
      var handleComponent = props.handleComponent,
          handleStyle = props.handleStyle,
          _props$datum = props.datum,
          datum = _props$datum === undefined ? {} : _props$datum,
          _props$activeBrushes2 = props.activeBrushes,
          activeBrushes = _props$activeBrushes2 === undefined ? {} : _props$activeBrushes2,
          brushDomain = props.brushDomain;

      if (!brushDomain) {
        return null;
      }
      var handleDimensions = this.getHandleDimensions(props);
      var style = _assign({}, fallbackProps.handleStyle, handleStyle);
      var minDatum = _assign({ handleValue: Collection.getMinValue(brushDomain) }, datum);
      var maxDatum = _assign({ handleValue: Collection.getMaxValue(brushDomain) }, datum);
      var minHandleProps = _assign({
        key: "min",
        style: Helpers.evaluateStyle(style, minDatum, activeBrushes.minHandle)
      }, handleDimensions.min);
      var maxHandleProps = _assign({
        key: "max",
        style: Helpers.evaluateStyle(style, maxDatum, activeBrushes.maxHandle)
      }, handleDimensions.max);
      return [React.cloneElement(handleComponent, minHandleProps), React.cloneElement(handleComponent, maxHandleProps)];
    }
  }, {
    key: "renderBrush",
    value: function renderBrush(props) {
      var brushComponent = props.brushComponent,
          brushStyle = props.brushStyle,
          _props$activeBrushes3 = props.activeBrushes,
          activeBrushes = _props$activeBrushes3 === undefined ? {} : _props$activeBrushes3,
          _props$datum2 = props.datum,
          datum = _props$datum2 === undefined ? {} : _props$datum2,
          brushDomain = props.brushDomain;

      if (!brushDomain) {
        return null;
      }
      var brushWidth = props.brushWidth || props.width;
      var rectDimensions = this.getRectDimensions(props, brushWidth);
      var baseStyle = _assign({}, fallbackProps.brushStyle, brushStyle);
      var style = Helpers.evaluateStyle(baseStyle, datum, activeBrushes.brush);
      var brushProps = _assign({ style: style }, rectDimensions);
      return React.cloneElement(brushComponent, brushProps);
    }
  }, {
    key: "renderBrushArea",
    value: function renderBrushArea(props) {
      var brushAreaComponent = props.brushAreaComponent,
          brushAreaStyle = props.brushAreaStyle,
          _props$activeBrushes4 = props.activeBrushes,
          activeBrushes = _props$activeBrushes4 === undefined ? {} : _props$activeBrushes4,
          _props$datum3 = props.datum,
          datum = _props$datum3 === undefined ? {} : _props$datum3;

      var brushAreaWidth = props.brushAreaWidth || props.width;
      var cursor = this.getCursor(props);
      var rectDimensions = this.getRectDimensions(props, brushAreaWidth, getFullDomain(props));
      var baseStyle = _assign({ cursor: cursor }, fallbackProps.brushAreaStyle, brushAreaStyle);
      var style = Helpers.evaluateStyle(baseStyle, datum, activeBrushes.brushArea);
      var brushAreaProps = _assign({ style: style }, rectDimensions);
      return React.cloneElement(brushAreaComponent, brushAreaProps);
    }
  }, {
    key: "renderLine",
    value: function renderLine(props) {
      var filteredProps = _pick(props, ["x1", "x2", "y1", "y2", "datum", "scale", "active", "style"]);
      return React.cloneElement(props.lineComponent, filteredProps);
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement(
        "g",
        this.props.events,
        this.renderLine(this.props),
        this.renderBrushArea(this.props),
        this.renderBrush(this.props),
        this.renderHandles(this.props)
      );
    }
  }]);

  return VictoryBrushLine;
}(React.Component);

VictoryBrushLine.propTypes = {
  allowDrag: PropTypes.bool,
  allowResize: PropTypes.bool,
  brushAreaComponent: PropTypes.element,
  brushAreaStyle: PropTypes.object,
  brushAreaWidth: PropTypes.number,
  brushComponent: PropTypes.element,
  brushDimension: PropTypes.oneOf(["x", "y"]),
  brushDomain: PropTypes.array,
  brushStyle: PropTypes.object,
  brushWidth: PropTypes.number,
  className: PropTypes.string,
  dimension: PropTypes.oneOf(["x", "y"]),
  disable: PropTypes.bool,
  events: PropTypes.object,
  groupComponent: PropTypes.element,
  handleComponent: PropTypes.element,
  handleStyle: PropTypes.object,
  handleWidth: PropTypes.number,
  lineComponent: PropTypes.element,
  name: PropTypes.string,
  onBrushDomainChange: PropTypes.func,
  scale: PropTypes.object,
  style: PropTypes.object,
  type: PropTypes.string,
  width: PropTypes.number
};
VictoryBrushLine.defaultProps = {
  allowDrag: true,
  allowResize: true,
  brushAreaComponent: React.createElement(Box, null),
  brushComponent: React.createElement(Box, null),
  groupComponent: React.createElement("g", null),
  handleComponent: React.createElement(Box, null),
  handleWidth: 10,
  lineComponent: React.createElement(Axis, null),
  width: 10
};

VictoryBrushLine.defaultEvents = function (props) {
  return props.disable ? undefined : [{
    target: props.type,
    eventHandlers: {
      onMouseEnter: function (evt, targetProps) {
        evt.preventDefault();
        var dimension = targetProps.dimension,
            allowResize = targetProps.allowResize,
            brushDomain = targetProps.brushDomain;

        var position = Selection.getSVGEventCoordinates(evt)[dimension];
        var fullDomain = getFullDomain(targetProps);
        var currentDomain = brushDomain || fullDomain;
        var range = toRange(targetProps, currentDomain);
        var activeHandle = allowResize && getActiveHandle(targetProps, position, range);
        var activeBrushes = {
          brushArea: !targetProps.brushDomain,
          brush: withinBound(position, range) && !isEqual(fullDomain, currentDomain),
          minHandle: activeHandle === "min" || activeHandle === "both",
          maxHandle: activeHandle === "min" || activeHandle === "both"
        };
        return [{
          mutation: function () {
            return { activeBrushes: activeBrushes, brushDomain: targetProps.brushDomain };
          }
        }];
      },
      onMouseDown: function (evt, targetProps) {
        evt.preventDefault();
        var allowResize = targetProps.allowResize,
            allowDrag = targetProps.allowDrag,
            dimension = targetProps.dimension,
            activeBrushes = targetProps.activeBrushes,
            brushDomain = targetProps.brushDomain;

        // Don't trigger events for static brushes

        if (!allowResize && !allowDrag) {
          return [];
        }

        var fullDomain = getFullDomain(targetProps);
        var currentDomain = brushDomain || fullDomain;
        var position = Selection.getSVGEventCoordinates(evt)[dimension];
        var range = toRange(targetProps, currentDomain);
        var activeHandle = allowResize && getActiveHandle(targetProps, position, range);
        // If the event occurs in any of the handle regions, start a resize
        if (activeHandle) {
          return [{
            mutation: function () {
              return {
                isSelecting: true, activeHandle: activeHandle,
                brushDomain: currentDomain,
                startPosition: position, activeBrushes: activeBrushes
              };
            }
          }];
        } else if (withinBound(position, range) && !isEqual(fullDomain, currentDomain)) {
          // if the event occurs within a selected region start a panning event, unless the whole
          // domain is selected
          return [{
            mutation: function () {
              return {
                isPanning: allowDrag, startPosition: position,
                brushDomain: currentDomain, activeBrushes: activeBrushes
              };
            }
          }];
        } else {
          // if the event occurs outside the region, or if the whole domain is selected,
          // start a new selection
          return allowResize ? [{
            mutation: function () {
              return {
                isSelecting: allowResize,
                brushDomain: null,
                startPosition: position,
                activeBrushes: activeBrushes
              };
            }
          }] : [];
        }
      },
      onMouseMove: function (evt, targetProps) {
        // eslint-disable-line max-statements, complexity
        var isPanning = targetProps.isPanning,
            isSelecting = targetProps.isSelecting,
            allowResize = targetProps.allowResize,
            allowDrag = targetProps.allowDrag,
            dimension = targetProps.dimension,
            onBrushDomainChange = targetProps.onBrushDomainChange,
            brushDomain = targetProps.brushDomain;

        if (isPanning || isSelecting) {
          evt.preventDefault();
          evt.stopPropagation();
        }
        var position = Selection.getSVGEventCoordinates(evt)[dimension];
        var fullDomain = getFullDomain(targetProps);
        var domain = brushDomain || fullDomain;
        var initialRange = toRange(targetProps, domain);
        var activeHandle = getActiveHandle(targetProps, position, initialRange);
        var activeBrushes = {
          brushArea: !targetProps.brushDomain,
          brush: withinBound(position, initialRange) && !isEqual(fullDomain, domain),
          minHandle: activeHandle === "min" || activeHandle === "both",
          maxHandle: activeHandle === "max" || activeHandle === "both"
        };
        if (!targetProps.isPanning && !targetProps.isSelecting) {
          return [{
            mutation: function () {
              return {
                activeBrushes: activeBrushes, brushDomain: targetProps.brushDomain
              };
            }
          }];
        }
        if (allowDrag && isPanning) {
          var fullRange = getFullRange(targetProps);
          var range = panBox(targetProps, position);
          var currentDomain = toDomain(targetProps, range);
          var startPosition = Math.max.apply(Math, _toConsumableArray(range)) >= Math.max.apply(Math, _toConsumableArray(fullRange)) || Math.min.apply(Math, _toConsumableArray(range)) <= Math.min.apply(Math, _toConsumableArray(fullRange)) ? targetProps.startPosition : position;
          var mutatedProps = {
            startPosition: startPosition, isPanning: true, brushDomain: currentDomain,
            activeBrushes: { brush: true }
          };

          if (_isFunction(onBrushDomainChange)) {
            onBrushDomainChange(currentDomain, _defaults({}, mutatedProps, targetProps));
          }
          return [{
            mutation: function () {
              return mutatedProps;
            }
          }];
        } else if (allowResize && isSelecting) {
          var _currentDomain = brushDomain || getMinimumDomain();
          var _range = toRange(targetProps, _currentDomain);
          var oppositeHandle = targetProps.activeHandle === "min" ? "max" : "min";
          var handle = targetProps.activeHandle && getActiveHandle(targetProps, position, _range) === "both" ? oppositeHandle : targetProps.activeHandle;
          if (!handle) {
            _currentDomain = toDomain(targetProps, [targetProps.startPosition, position]);
          } else {
            var rangeMax = dimension === "x" ? Math.max.apply(Math, _toConsumableArray(_range)) : Math.min.apply(Math, _toConsumableArray(_range));
            var rangeMin = dimension === "x" ? Math.min.apply(Math, _toConsumableArray(_range)) : Math.max.apply(Math, _toConsumableArray(_range));
            var min = handle === "max" ? rangeMin : position;
            var max = handle === "min" ? rangeMax : position;
            _currentDomain = toDomain(targetProps, [min, max]);
          }
          var _mutatedProps = {
            brushDomain: _currentDomain, startPosition: targetProps.startPosition,
            isSelecting: isSelecting, activeHandle: handle,
            activeBrushes: {
              brush: true, minHandle: activeHandle === "min", maxHandle: activeHandle === "max"
            }
          };
          if (_isFunction(onBrushDomainChange)) {
            onBrushDomainChange(_currentDomain, _defaults({}, _mutatedProps, targetProps));
          }
          return [{
            mutation: function () {
              return _mutatedProps;
            }
          }];
        }
        return [];
      },
      onMouseUp: function (evt, targetProps) {
        var onBrushDomainChange = targetProps.onBrushDomainChange,
            brushDomain = targetProps.brushDomain,
            allowResize = targetProps.allowResize,
            activeBrushes = targetProps.activeBrushes;
        // if the mouse hasn't moved since a mouseDown event, select the whole domain region

        var mutatedProps = {
          isPanning: false, isSelecting: false, activeHandle: null, startPosition: null,
          brushDomain: brushDomain, activeBrushes: activeBrushes
        };
        if (allowResize && _isFunction(onBrushDomainChange)) {
          onBrushDomainChange(brushDomain, _defaults({}, mutatedProps, targetProps));
        }
        return [{
          mutation: function () {
            return mutatedProps;
          }
        }];
      },
      onMouseLeave: function (evt, targetProps) {
        var brushDomain = targetProps.brushDomain;

        return [{
          mutation: function () {
            return {
              isPanning: false, isSelecting: false, activeHandle: null, startPosition: null,
              brushDomain: brushDomain, activeBrushes: {}
            };
          }
        }];
      }
    }
  }];
};

export default VictoryBrushLine;