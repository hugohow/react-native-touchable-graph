import _sortBy from "lodash/sortBy";
import _flatten from "lodash/flatten";
import _isArray from "lodash/isArray";
import _defaults from "lodash/defaults";
import _assign from "lodash/assign";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { Helpers, LabelHelpers, Scale, Domain, Data } from "victory-core";

var getErrors = function (datum, scale, axis) {
  /**
   * check if it is asymmetric error or symmetric error, asymmetric error should be an array
   * and the first value is the positive error, the second is the negative error
   * @param  {Boolean} isArray(errorX)
   * @return {String or Array}
   */

  var errorNames = { x: "errorX", y: "errorY" };
  var errors = datum[errorNames[axis]];
  if (errors === 0) {
    return false;
  }

  return _isArray(errors) ? [errors[0] === 0 ? false : scale[axis](errors[0] + datum["_" + axis]), errors[1] === 0 ? false : scale[axis](datum["_" + axis] - errors[1])] : [scale[axis](errors + datum["_" + axis]), scale[axis](datum["_" + axis] - errors)];
};

var sortData = function (dataset, sortKey) {
  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "ascending";

  if (!sortKey) {
    return dataset;
  }

  if (sortKey === "x" || sortKey === "y") {
    sortKey = "_" + sortKey;
  }

  var sortedData = _sortBy(dataset, sortKey);

  if (sortOrder === "descending") {
    return sortedData.reverse();
  }

  return sortedData;
};

var formatErrorData = function (dataset, props) {
  if (!dataset || Data.getLength(dataset) < 1) {
    return [];
  }
  var accessor = {
    x: Helpers.createAccessor(props.x !== undefined ? props.x : "x"),
    y: Helpers.createAccessor(props.y !== undefined ? props.y : "y"),
    errorX: Helpers.createAccessor(props.errorX !== undefined ? props.errorX : "errorX"),
    errorY: Helpers.createAccessor(props.errorY !== undefined ? props.errorY : "errorY")
  };

  var replaceNegatives = function (errors) {
    // check if the value is negative, if it is set to 0
    var replaceNeg = function (val) {
      return !val || val < 0 ? 0 : val;
    };
    return _isArray(errors) ? errors.map(function (err) {
      return replaceNeg(err);
    }) : replaceNeg(errors);
  };

  var stringMap = {
    x: Data.createStringMap(props, "x"),
    y: Data.createStringMap(props, "y")
  };

  var formattedData = dataset.reduce(function (dataArr, datum, index) {
    datum = Data.parseDatum(datum);

    var evaluatedX = accessor.x(datum);
    var evaluatedY = accessor.y(datum);
    var _x = evaluatedX !== undefined ? evaluatedX : index;
    var _y = evaluatedY !== undefined ? evaluatedY : datum;
    var errorX = replaceNegatives(accessor.errorX(datum));
    var errorY = replaceNegatives(accessor.errorY(datum));

    dataArr.push(_assign({}, datum, { _x: _x, _y: _y, errorX: errorX, errorY: errorY },
    // map string data to numeric values, and add names
    typeof _x === "string" ? { _x: stringMap.x[_x], x: _x } : {}, typeof _y === "string" ? { _y: stringMap.y[_y], y: _y } : {}));

    return dataArr;
  }, []);

  return sortData(formattedData, props.sortKey, props.sortOrder);
};

var getErrorData = function (props) {
  if (props.data) {
    if (Data.getLength(props.data) < 1) {
      return [];
    }

    return formatErrorData(props.data, props);
  } else {
    var generatedData = (props.errorX || props.errorY) && Data.generateData(props);
    return formatErrorData(generatedData, props);
  }
};

var getDomainFromData = function (props, axis, dataset) {
  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);
  var error = void 0;
  if (currentAxis === "x") {
    error = "errorX";
  } else if (currentAxis === "y") {
    error = "errorY";
  }
  var axisData = _flatten(dataset).map(function (datum) {
    return datum["_" + currentAxis];
  });
  var errorData = _flatten(_flatten(dataset).map(function (datum) {
    var errorMax = void 0;
    var errorMin = void 0;
    if (_isArray(datum[error])) {
      errorMax = datum[error][0] + datum["_" + currentAxis];
      errorMin = datum["_" + currentAxis] - datum[error][1];
    } else {
      errorMax = datum[error] + datum["_" + currentAxis];
      errorMin = datum["_" + currentAxis] - datum[error];
    }
    return [errorMax, errorMin];
  }));

  var allData = axisData.concat(errorData);
  var min = Math.min.apply(Math, _toConsumableArray(allData));
  var max = Math.max.apply(Math, _toConsumableArray(allData));
  // TODO: is the correct behavior, or should we just error. How do we
  // handle charts with just one data point?
  if (+min === +max) {
    return Domain.getSinglePointDomain(max);
  }
  return [min, max];
};

var getDomain = function (props, axis) {
  var propsDomain = Domain.getDomainFromProps(props, axis);
  if (propsDomain) {
    return Domain.padDomain(propsDomain, props, axis);
  }
  var categoryDomain = Domain.getDomainFromCategories(props, axis);
  if (categoryDomain) {
    return Domain.padDomain(categoryDomain, props, axis);
  }
  var dataset = getErrorData(props);

  if (dataset.length < 1) {
    return Scale.getBaseScale(props, axis).domain();
  }

  var domain = getDomainFromData(props, axis, dataset);
  return Domain.cleanDomain(Domain.padDomain(domain, props, axis), props);
};

var getCalculatedValues = function (props) {
  var defaultStyles = props.theme && props.theme.errorbar && props.theme.errorbar.style ? props.theme.errorbar.style : {};
  var style = Helpers.getStyles(props.style, defaultStyles) || {};
  var dataWithErrors = _assign(Data.getData(props), getErrorData(props));
  var data = Data.addEventKeys(props, dataWithErrors);
  var range = {
    x: Helpers.getRange(props, "x"),
    y: Helpers.getRange(props, "y")
  };
  var domain = {
    x: getDomain(props, "x"),
    y: getDomain(props, "y")
  };
  var scale = {
    x: Scale.getBaseScale(props, "x").domain(domain.x).range(range.x),
    y: Scale.getBaseScale(props, "y").domain(domain.y).range(range.y)
  };
  var origin = props.polar ? props.origin || Helpers.getPolarOrigin(props) : undefined;
  return { domain: domain, data: data, scale: scale, style: style, origin: origin };
};

var getLabelProps = function (dataProps, text, style) {
  var x = dataProps.x,
      index = dataProps.index,
      scale = dataProps.scale,
      errorY = dataProps.errorY;

  var error = errorY && Array.isArray(errorY) ? errorY[0] : errorY;
  var y = error || dataProps.y;
  var labelStyle = style.labels || {};
  return {
    style: labelStyle,
    y: y - (labelStyle.padding || 0),
    x: x,
    text: text,
    index: index,
    scale: scale,
    datum: dataProps.datum,
    data: dataProps.data,
    textAnchor: labelStyle.textAnchor,
    verticalAnchor: labelStyle.verticalAnchor || "end",
    angle: labelStyle.angle
  };
};

var getDataStyles = function (datum, style) {
  return _defaults({}, datum, style);
};

var getBaseProps = function (props, fallbackProps) {
  props = Helpers.modifyProps(props, fallbackProps, "errorbar");

  var _getCalculatedValues = getCalculatedValues(props, fallbackProps),
      data = _getCalculatedValues.data,
      style = _getCalculatedValues.style,
      scale = _getCalculatedValues.scale,
      domain = _getCalculatedValues.domain,
      origin = _getCalculatedValues.origin;

  var _props = props,
      groupComponent = _props.groupComponent,
      height = _props.height,
      width = _props.width,
      borderWidth = _props.borderWidth,
      standalone = _props.standalone,
      theme = _props.theme,
      polar = _props.polar,
      padding = _props.padding;

  var initialChildProps = { parent: {
      domain: domain, scale: scale, data: data, height: height, width: width, standalone: standalone, theme: theme, polar: polar, origin: origin,
      padding: padding, style: style.parent
    } };

  return data.reduce(function (childProps, datum, index) {
    var eventKey = datum.eventKey || index;
    var x = scale.x(datum._x1 !== undefined ? datum._x1 : datum._x);
    var y = scale.y(datum._y1 !== undefined ? datum._y1 : datum._y);

    var dataProps = {
      x: x, y: y, scale: scale, datum: datum, data: data, index: index, groupComponent: groupComponent, borderWidth: borderWidth,
      style: getDataStyles(datum, style.data),
      errorX: getErrors(datum, scale, "x"),
      errorY: getErrors(datum, scale, "y")
    };

    childProps[eventKey] = {
      data: dataProps
    };
    var text = LabelHelpers.getText(props, datum, index);
    if (text !== undefined && text !== null || props.events || props.sharedEvents) {
      childProps[eventKey].labels = getLabelProps(dataProps, text, style);
    }

    return childProps;
  }, initialChildProps);
};

export { getBaseProps, getDomain };